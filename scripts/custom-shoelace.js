import { intro, outro, text, select, confirm, spinner, isCancel, cancel } from '@clack/prompts';
import download from 'download-git-repo';
import fs from 'fs';
import path from 'path';
import { getDependencies } from './get-dependencies.js';
import { resetDirectory, createFiles } from './create-autogenerated-files.js';
import { changeShoelaceBranding } from './change-shoelace-branding.js';

const CONFIG_FILE = 'custom-shoelace.config.json';
const repo = 'shoelace-style/shoelace';

intro('ðŸ¥¾ Custom Shoelace CLI');

function readConfig() {
  return fs.existsSync(CONFIG_FILE) ? JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8')) : {};
}

function saveConfig(config) {
  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
}

async function getConfigParam(paramName, message, placeholder, pattern, errorMessage) {
  let paramValue = readConfig()[paramName];
  if (!paramValue) {
    paramValue = await text({
      message,
      placeholder,
      validate(value) {
        if (value && !pattern.test(value)) return errorMessage;
      },
    });
    const config = readConfig();
    config[paramName] = paramValue;
    saveConfig(config);
  }
  return paramValue;
}

function deleteFolderRecursive(directory) {
  if (fs.existsSync(directory)) {
    fs.readdirSync(directory).forEach(file => {
      const curPath = path.join(directory, file);
      fs.lstatSync(curPath).isDirectory() ? deleteFolderRecursive(curPath) : fs.unlinkSync(curPath);
    });
    fs.rmdirSync(directory);
  }
}

async function main() {
  const command = await select({
    message: 'What do you want to do?',
    options: [
      { value: 'autogenerate', label: 'Autogenerate Shoelace files', hint: 'This will include all dependent scripts and components, too.' },
      { value: 'download', label: 'Download Shoelace', hint: 'This will automatically generate your Shoelace files, too.' },
    ],
  });

  if (isCancel(command)) {
    cancel('Operation cancelled.');
    process.exit(0);
  }

  const s = spinner();
  const libraryName = await getConfigParam('libraryName', "What's the name of your library? (only lowercase letters)", 'shoelace', /^[a-z]+$/, 'Only lowercase letters are allowed');
  const libraryPrefix = await getConfigParam('libraryPrefix', "What's the prefix of your components? (only lowercase letters)", 'sl', /^[a-z]+$/, 'Only lowercase letters are allowed');

  if (command === 'download') {
    let version;
    if (!readConfig().shoelaceVersion) {
      version = await select({
        message: 'Which version do you want to install?',
        options: [
          'next', 'v2.6.0', 'v2.5.2', 'v2.5.1', 'v2.5.0', 'v2.4.0', 'v2.3.0', 'v2.2.0', 'v2.1.0', 'v2.0.0'
        ].map(value => ({ value })),
      });
    } else {
      version = readConfig().shoelaceVersion
    }

    if (isCancel(version)) {
      cancel('Operation cancelled.');
      process.exit(0);
    }

    const shouldContinue = await confirm({
      message: `Do you want to continue? This will delete everything in ${readConfig().vendorPath}, remove your old autogenerated files create the new ones.`,
    });

    if (isCancel(shouldContinue) || !shouldContinue) {
      cancel('Operation cancelled.');
      process.exit(0);
    }

    // Cleanup target directory before downloading
    deleteFolderRecursive(readConfig().vendorPath);
    fs.mkdirSync(readConfig().vendorPath, { recursive: true });


    s.start(`â³ Downloading Shoelace ${version}`);
    await new Promise((resolve, reject) => {
      download(`${repo}#${version}`, readConfig().vendorPath, err => {
        if (err) reject(`Error downloading repo: ${err}`);
        else resolve();
      });
    });
    s.stop(`âœ… Download completed`);

    s.start(`â³ Update library name + prefix`);
    changeShoelaceBranding(readConfig().vendorPath, libraryName, libraryPrefix);
    s.stop(`âœ… Library name + prefix updated`);
  }

  s.start(`â³ Calculate dependencies`);
  const components = readConfig().components.map(component => `src/components/${component}/${component}.ts`);
  const files = await getDependencies(components, readConfig().vendorPath);
  s.stop(`âœ… Dependencies calculated`);

  s.start(`â³ Remove old autogenerated files`);
  await resetDirectory(readConfig().targetPath);
  s.stop(`âœ… Old autogenerated files removed`);

  s.start(`â³ Write new autogenerated files`);
  files.forEach(file => {
    createFiles(readConfig().vendorPath, readConfig().targetPath, file);
  });
  s.stop(`âœ… New autogenerated files written`);

  outro(`ðŸŽ‰ ${libraryName} is now set. Remember to update ${libraryName}.ts if you added/removed components.`);
}
main();
